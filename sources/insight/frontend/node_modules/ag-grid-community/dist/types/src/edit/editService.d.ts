import type { NamedBean } from '../context/bean';
import { BeanStub } from '../context/beanStub';
import type { AgEventType } from '../eventTypes';
import type { BatchEditingStartedEvent, BatchEditingStoppedEvent, CellFocusedEvent } from '../events';
import type { CellRange } from '../interfaces/IRangeService';
import type { EditingCellPosition, ICellEditorParams, ICellEditorValidationError } from '../interfaces/iCellEditor';
import type { RefreshCellsParams } from '../interfaces/iCellsParams';
import type { Column } from '../interfaces/iColumn';
import type { EditMap } from '../interfaces/iEditModelService';
import type { CellValueResolveFrom, EditNavOnValidationResult, EditPosition, EditSource, IsEditingParams, StartEditParams, StopEditParams, _SetEditingCellsParams } from '../interfaces/iEditService';
import type { IRowNode } from '../interfaces/iRowNode';
import type { IRowStyleFeature } from '../interfaces/iRowStyleFeature';
import type { UserCompDetails } from '../interfaces/iUserCompDetails';
import { CellCtrl } from '../rendering/cell/cellCtrl';
import type { RowCtrl } from '../rendering/row/rowCtrl';
import { PopupEditorWrapper } from './cellEditors/popupEditorWrapper';
import { CellEditStyleFeature } from './styles/cellEditStyleFeature';
type BatchPrepDetails = {
    compDetails?: UserCompDetails;
    valueToDisplay?: any;
};
export declare class EditService extends BeanStub implements NamedBean {
    beanName: "editSvc";
    committing: boolean;
    private batch;
    private batchStartDispatched;
    private model;
    private valueSvc;
    private rangeSvc;
    private strategy?;
    private stopping;
    private rangeSelectionWhileEditing;
    postConstruct(): void;
    isBatchEditing(): boolean;
    startBatchEditing(): void;
    stopBatchEditing(params?: StopEditParams): void;
    /** Lazily dispatch batchEditingStarted when the first write or editor open occurs during a batch session. */
    private ensureBatchStarted;
    private createStrategy;
    private destroyStrategy;
    shouldStartEditing(position: Required<EditPosition>, event?: KeyboardEvent | MouseEvent | null, cellStartedEdit?: boolean | null, source?: EditSource): boolean;
    shouldStopEditing(position?: EditPosition, event?: KeyboardEvent | MouseEvent | null | undefined, source?: EditSource): boolean | null;
    shouldCancelEditing(position?: EditPosition, event?: KeyboardEvent | MouseEvent | null | undefined, source?: EditSource): boolean | null;
    validateEdit(): ICellEditorValidationError[] | null;
    isEditing(position?: EditPosition | null, params?: IsEditingParams): boolean;
    isRowEditing(rowNode?: IRowNode, params?: IsEditingParams): boolean;
    enableRangeSelectionWhileEditing(): void;
    disableRangeSelectionWhileEditing(): void;
    isRangeSelectionEnabledWhileEditing(): boolean;
    /** @returns whether to prevent default on event */
    startEditing(position: Required<EditPosition>, params: StartEditParams): void;
    stopEditing(position?: EditPosition, params?: StopEditParams): boolean;
    private prepareStopContext;
    private processStopRequest;
    private handleStopOrCancel;
    private shouldHandleMidBatchKey;
    private handleMidBatchKey;
    private finishStopEditing;
    /** Dispatch batchEditingStopped if batchEditingStarted was (or should have been) dispatched. */
    private dispatchBatchStopped;
    private clearValidationIfNoOpenEditors;
    private navigateAfterEdit;
    private processEdits;
    /**
     * Commits a value to the row node's data via `rowNode.setDataValue`.
     *
     * This is a low-level helper that only writes to data; it does NOT update the
     * edit model. Callers are responsible for any model reconciliation â€” see
     * `syncEditAfterCommit` for the non-batch case and `processEdits` for the
     * batch-finalisation case (where edits are removed immediately after commit).
     */
    private setNodeDataValue;
    /**
     * Syncs the edit model after a non-batch commit so sourceValue never becomes stale.
     * On success, re-reads the actual committed value from data (via getValue) because
     * a custom valueSetter may transform or store it differently than the passed value.
     * On failure, reverts the pending edit back to sourceValue.
     *
     * Skipped when an editor is open (state === 'editing'), because the upcoming
     * stopEditing flow will call _syncFromEditors which reads from the editor widget;
     * updating sourceValue here would cause that flow to re-commit stale editor content.
     *
     * NOTE: The re-read via `getValue` happens after `setNodeDataValue` has dispatched
     * `cellValueChanged`. If a `cellValueChanged` listener synchronously mutates the
     * same data field, the re-read will pick up that mutation. This is acceptable because
     * the listener intentionally transformed the value and the model should track the
     * actual committed state.
     */
    private syncEditAfterCommit;
    setEditMap(edits: EditMap, params?: _SetEditingCellsParams): void;
    private dispatchEditValuesChanged;
    bulkRefresh(position?: EditPosition, editMap?: EditMap, params?: RefreshCellsParams): void;
    private refCell;
    stopAllEditing(cancel?: boolean, source?: 'api' | 'ui'): void;
    isCellEditable(position: Required<EditPosition>, source?: 'api' | 'ui'): boolean;
    cellEditingInvalidCommitBlocks(): boolean;
    checkNavWithValidation(position?: EditPosition, event?: Event | CellFocusedEvent, focus?: boolean): EditNavOnValidationResult;
    revertSingleCellEdit(cellPosition: Required<EditPosition>, focus?: boolean): void;
    hasValidationErrors(position?: EditPosition): boolean;
    moveToNextCell(prev: CellCtrl | RowCtrl, backwards: boolean, event?: KeyboardEvent, source?: 'api' | 'ui'): boolean | null;
    /**
     * Gets the pending edit value for a cell (used by ValueService).
     * Returns undefined to fallback to committed data/valueGetter.
     */
    getPendingEditValue(rowNode: IRowNode, column: Column, from: CellValueResolveFrom): any;
    getCellDataValue(position: Required<EditPosition>): any;
    addStopEditingWhenGridLosesFocus(viewports: HTMLElement[]): void;
    createPopupEditorWrapper(params: ICellEditorParams): PopupEditorWrapper;
    batchResetToSourceValue(position: Required<EditPosition>): boolean;
    /**
     * Applies a data value change to a cell, handling batch editing, undo/redo, paste, and range operations.
     */
    setDataValue(position: Required<EditPosition>, newValue: any, eventSource?: string): boolean | undefined;
    /** Handles setDataValue when an edit already exists for the cell. */
    private applyExistingEdit;
    /** editApi or undoRedoApi apply change without involving the editor. */
    private applyDirectValue;
    handleColDefChanged(cellCtrl: CellCtrl): void;
    destroy(): void;
    prepDetailsDuringBatch(position: Required<EditPosition>, params: BatchPrepDetails): BatchPrepDetails | undefined;
    cleanupEditors(): void;
    dispatchCellEvent<T extends AgEventType>(position: Required<EditPosition>, event?: Event | null, type?: T, payload?: any): void;
    dispatchBatchEvent(type: 'batchEditingStarted' | 'batchEditingStopped', edits: EditMap): void;
    createBatchEditEvent(type: 'batchEditingStarted' | 'batchEditingStopped', edits: EditMap): BatchEditingStartedEvent | BatchEditingStoppedEvent;
    private toEventChangeList;
    applyBulkEdit({ rowNode, column }: Required<EditPosition>, ranges: CellRange[]): void;
    createCellStyleFeature(cellCtrl: CellCtrl): CellEditStyleFeature;
    createRowStyleFeature(rowCtrl: RowCtrl): IRowStyleFeature;
    setEditingCells(cells: EditingCellPosition[], params?: _SetEditingCellsParams): void;
    onCellFocused(event: CellFocusedEvent): void;
    allowedFocusTargetOnValidation(cellPosition: EditPosition): CellCtrl | undefined;
}
export {};
