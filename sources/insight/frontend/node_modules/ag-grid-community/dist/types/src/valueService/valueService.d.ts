import type { NamedBean } from '../context/bean';
import { BeanStub } from '../context/beanStub';
import type { BeanCollection } from '../context/context';
import type { AgColumn } from '../entities/agColumn';
import type { CellValueResolveFrom } from '../interfaces/iEditService';
import type { IRowNode } from '../interfaces/iRowNode';
export declare class ValueService extends BeanStub implements NamedBean {
    beanName: "valueSvc";
    private expressionSvc?;
    private colModel;
    private valueCache?;
    private dataTypeSvc?;
    private editSvc?;
    private formulaDataSvc?;
    wireBeans(beans: BeanCollection): void;
    private cellExpressions;
    private isTreeData;
    private initialised;
    private isSsrm;
    private executeValueGetter;
    postConstruct(): void;
    private init;
    /**
     * Use this function to get a displayable cell value.
     * The values from this function are not used for sorting, filtering, or aggregation purposes.
     * Handles: groupHideOpenParents, showOpenedGroup and groupSuppressBlankHeader behaviours
     */
    getValueForDisplay(params: {
        column?: AgColumn;
        node: IRowNode;
        includeValueFormatted?: boolean;
        useRawFormula?: boolean;
        exporting?: boolean;
        from: CellValueResolveFrom;
    }): {
        value: any;
        valueFormatted: string | null;
    };
    getValue(column: AgColumn, rowNode: IRowNode | null | undefined, from: CellValueResolveFrom, ignoreAggData?: boolean): any;
    private getFormulaFromDataSource;
    /** Computes whether to ignore aggregation data for display purposes. */
    private displayIgnoresAggData;
    private resolveValue;
    parseValue<TValueNew = any, TValueOld = any, TValue = any>(column: AgColumn, rowNode: IRowNode | null, newValue: TValueNew, oldValue: TValueOld): TValue;
    getDeleteValue(column: AgColumn, rowNode: IRowNode): any;
    formatValue(column: AgColumn, node: IRowNode | null, value: any, suppliedFormatter?: (value: any) => string, useFormatterFromColumn?: boolean): string | null;
    /**
     * Sets the value of a GridCell
     * @param rowNode The `RowNode` to be updated
     * @param column The `Column` to be updated
     * @param newValue The new value to be set
     * @param eventSource The event source
     * @returns `true` if the value has been updated, otherwise `false`.
     */
    setValue(rowNode: IRowNode, column: AgColumn, newValue: any, eventSource?: string): boolean;
    private canCreateRowNodeData;
    private finishValueChange;
    private isSetValueSupported;
    private handleExternalFormulaChange;
    private computeValueChange;
    private dispatchCellValueChangedEvent;
    private callColumnCellValueChangedHandler;
    private setValueUsingField;
    private executeValueGetterWithValueCache;
    private executeValueGetterWithoutValueCache;
    getValueCallback(node: IRowNode, field: string | AgColumn): any;
    getKeyForNode(col: AgColumn, rowNode: IRowNode): any;
}
