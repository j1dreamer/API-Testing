import type { NamedBean } from '../context/bean';
import { BeanStub } from '../context/beanStub';
import { RowNode } from '../entities/rowNode';
import type { IClientSideRowModel, RefreshModelParams } from '../interfaces/iClientSideRowModel';
import type { ForEachNodeCallback, RowBounds, RowModelType } from '../interfaces/iRowModel';
import type { RowDataTransaction } from '../interfaces/rowDataTransaction';
import type { RowNodeTransaction } from '../interfaces/rowNodeTransaction';
import type { OverlayType } from '../rendering/overlays/overlayComponent';
import { ChangedPath } from '../utils/changedPath';
export declare class ClientSideRowModel extends BeanStub implements IClientSideRowModel, NamedBean {
    beanName: "rowModel";
    rootNode: RowNode | null;
    /** Public-readonly flag indicating row count is ready for external consumers. */
    rowCountReady: boolean;
    /** Manages the row nodes, including creation, update, and removal. */
    private nodeManager;
    /** The rows mapped to rows to display, during the 'map' stage. */
    private rowsToDisplay;
    /** Row nodes used for formula calculations when formula feature is active. */
    private formulaRows;
    /** The ordered list of row processing stages: group → filter → pivot → aggregate → filterAggregates → sort → flatten. */
    private stages;
    /** Queued async transactions waiting to be processed. */
    private asyncTransactions;
    /** Timer handle for batching async transactions. */
    private asyncTransactionsTimer;
    /** Has the start() method been called. */
    private started;
    /** Set to true when row data is being updated. Reset when model is fully refreshed. */
    private refreshingData;
    /** Keep track if row data was updated. Important with suppressModelUpdateAfterUpdateTransaction and refreshModel api is called. */
    private rowDataUpdatedPending;
    /**
     * This is to prevent refresh model being called when it's already being called.
     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,
     * which then triggers the listener here that calls refresh model again but at the filter stage
     * (which is about to be run by the original call).
     */
    private refreshingModel;
    /** Set by nested refresh calls to force newData=true in the final modelUpdated event. */
    private pendingNewData;
    /** Set by nested reMapRows() or refreshModel() calls to force keepRenderedRows=false in the final modelUpdated event. */
    private noKeepRenderedRows;
    /** Set by nested reMapRows() or refreshModel() calls to force keepUndoRedoStack=false in the final modelUpdated event. */
    private noKeepUndoRedoStack;
    /** Set by nested refresh calls to prevent animate=true in the final modelUpdated event when any call didn't allow animation. */
    private noAnimate;
    /** True after the first time row nodes have been created or data has been set. Used to determine when to fire rowCountReady. */
    private rowNodesCountReady;
    /** Maps a property name to the index in this.stages array */
    private readonly stagesRefreshProps;
    postConstruct(): void;
    private addPropertyListeners;
    start(): void;
    private setInitialData;
    ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number): boolean;
    private onPropChange;
    private getRefreshedStage;
    private setRowTopAndRowIndex;
    private clearRowTopAndRowIndex;
    isLastRowIndexKnown(): boolean;
    getRowCount(): number;
    /**
     * Returns the number of rows with level === 1
     */
    getTopLevelRowCount(): number;
    /**
     * Get the row display index by the top level index
     * top level index is the index of rows with level === 1
     */
    getTopLevelRowDisplayedIndex(topLevelIndex: number): number;
    /**
     * The opposite of `getTopLevelRowDisplayedIndex`
     */
    getTopLevelIndexFromDisplayedIndex(displayedIndex: number): number;
    getRowBounds(index: number): RowBounds | null;
    private onRowGroupOpened;
    private onFilterChanged;
    private onSortChanged;
    getType(): RowModelType;
    private onValueChanged;
    private createChangePath;
    private isSuppressModelUpdateAfterUpdateTransaction;
    /**
     * Performs a map-only refresh. Safe to call during an active refresh.
     * If a refresh is in progress, flags are captured and applied to the outer refresh.
     * Flag accumulation is intentional - they persist until the next successful refreshModel().
     */
    reMapRows(): void;
    refreshModel(params: RefreshModelParams): void;
    /** Executes the refresh pipeline stages and updates row positions. */
    private executeRefresh;
    /** Checks if the refresh should be deferred. Caller must call setPendingRefreshFlags when this returns true. */
    private deferRefresh;
    /** Captures flags from deferred refresh calls to apply to the eventual modelUpdated event. */
    private setPendingRefreshFlags;
    /** Clears pending refresh flags. Called at the end of a successful refreshModel. */
    private clearPendingRefreshFlags;
    /** Updates the params to reflect any forced flags from nested refresh calls. */
    private updateRefreshParams;
    isEmpty(): boolean;
    isRowsToRender(): boolean;
    getOverlayType(): OverlayType | null;
    getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode): RowNode[];
    getTopLevelNodes(): RowNode[] | null;
    getRow(index: number): RowNode;
    getFormulaRow(index: number): RowNode;
    isRowPresent(rowNode: RowNode): boolean;
    getRowIndexAtPixel(pixelToMatch: number): number;
    private isRowInPixel;
    forEachLeafNode(callback: ForEachNodeCallback): void;
    forEachNode(callback: ForEachNodeCallback, includeFooterNodes?: boolean): void;
    forEachDisplayedNode(callback: ForEachNodeCallback): void;
    forEachNodeAfterFilter(callback: ForEachNodeCallback, includeFooterNodes?: boolean): void;
    forEachNodeAfterFilterAndSort(callback: ForEachNodeCallback, includeFooterNodes?: boolean): void;
    forEachPivotNode(callback: ForEachNodeCallback, includeFooterNodes?: boolean, afterSort?: boolean): void;
    /**
     * Iterate through each node and all of its children
     * @param callback the function to execute for each node
     * @param includeFooterNodes whether to also iterate over footer nodes
     * @param nodes the nodes to start iterating over
     * @param getChildren a function to determine the recursion strategy
     * @param startIndex the index to start from
     * @returns the index ended at
     */
    private depthFirstSearchRowNodes;
    doAggregate(changedPath: ChangedPath): void;
    private doFilterAggregates;
    private doSort;
    private doGrouping;
    private doFilter;
    private doPivot;
    getRowNode(id: string): RowNode | undefined;
    batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void): void;
    flushAsyncTransactions(): void;
    private executeBatchUpdateRowData;
    /**
     * Used to apply transaction changes.
     * Called by gridApi & rowDragFeature
     */
    updateRowData(rowDataTran: RowDataTransaction): RowNodeTransaction | null;
    /**
     * Common to:
     * - executeBatchUpdateRowData (batch transactions)
     * - updateRowData (single transaction)
     * - setImmutableRowData (generated transaction)
     *
     * @param rowNodeTrans - the transactions to apply
     * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
     */
    private commitTransactions;
    /** 'map' stage */
    private doRowsToDisplay;
    onRowHeightChanged(): void;
    resetRowHeights(): void;
    private resetRowHeightsForAllRowNodes;
    private onGridStylesChanges;
    private onGridReady;
    destroy(): void;
    private readonly onRowHeightChanged_debounced;
    /**
     * @deprecated v33.1
     */
    onRowHeightChangedDebounced(): void;
}
